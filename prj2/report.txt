Νικόλας Νικολακόπουλος - sdi1800133

command για bash script(αφού υπάρχει το αρχικό αρχείο input_file):
bash ./create_infiles.sh inputFile.txt ./input_dir 3

command για να τρέξουμε την εργασία, αφού κάναμε make:
./main -m 4 -b 1024 -s 100000 -i ./input_dir

Κατ'αρχάς, ο πατέρας κάνει τις απαραίτητες ενέργειες αρχικοποίησης, όπως
- η διαγραφή ενός καταλόγου "./pipes"(εάν υπάρχει ήδη) και την δημιουργεία νέου κενού, για την μετέπειτα 
αποθήκευση των fifo's σε αυτόν, 
-διαγραφή του καταλόγου "./logs" όπου αποθηκεύονται όλα τα log files,
-αρχικοποίηση για τον χειρισμό των signals, 
κτλ...

Έπειτα, δημιουργεί όσα Monitor proccesses έχει ζητηθεί και φτιάχνει και 2 named pipes για καθένα από αυτά.

Για την επικοινωνία μεταξύ τους, έχω ορίσει ένα πρωτόκολλο.
Το πρώτο byte είναι ο αριθμός πρωτοκόλλου, είναι είτε ένας αριθμός ή γράμμα, και κάθε ένα έχει διαφορετική σημασία.
Τα επόμενα 9 bytes είναι το πραγματικό μέγεθος του μηνύματος. 
Τέλος, ακολουθεί το μήνυμα.

Αφού φτιαχτούν τα monitors, ο πατέρας στέλνει απαραίτητες πληροφορίες όπως το bloom size και το pipe buffer size
στα παιδιά και εν συνεχεία στέλνει τις χώρες που θα αναλάβει κάθε παιδί.
Το κάθε παιδί ανοίγει τα αρχεία και οργανώνει τις δομές του.
Η αποθήκευση των εγγραφών στα monitors πραγματοποιείται όπως στην πρώτη εργασία.
Αποθηκεύονται σε hashtable , ενώ κρατάω και μια λίστα για κάθε ιό και σε αυτή τη λίστα έχω τα bloom filters
και κάποιες άλλες πληροφορίες, όπως το bloom size, pipe buffer size, αλλα και skip lists για τα τη γρηγορότερη 
αναζήτηση των εγγραφών για τη συνάρτηση /travelRequest. 


Στη συνέχεια υπάρχουν 3 στάδια:
1)init_monitors: Τα παιδία στέλνουν μήνυμα στον πατέρα ότι όλα έλαβαν τις χώρες.
2)ready_for_bloom: Ο πατέρας στέλνει μήνυμα στα παιδιά ότι είναι πλέον έτοιμος να
λάβει τα bloom filters.
3)updateDatabase: Ο πατέρας διαβάζει τα bloom filters από τα παιδιά και τα αποθηκεύει σε μια λίστα
της μορφής " node = country -> list:viruses -> each virus has its own bloom filters and some other info"
Ο κάθε κόμβος country αναφέρεται στο αντίστοιχο monitor όλων των χωρών που έχει αναλάβει.
Αξιοσημείωτο είναι ότι, επειδή τα bloom filter έχουν μεγάλο μέγεθος, το παιδί το στέλνει επαναληπτικά και
στο τέλος στέλνει μήνυμα ότι τέλειωσε την μετάδοση αυτού του bloom filter.

Καθ'όλη αυτή τη διάρκεια τα signals είχαν μπλοκαριστεί. Στη συνέχει τα ξεμπλοκάρουμε και τα ξαναμπλοκάρουμε για να δούμε αν 
έχουμε δεχθεί κάποιο signal. Έπειτα , ξεμπλοκάρουμε και περίμενουμε για κάποια εντολή του χρήστη.

Για την αποθήκευση των πληροφοριών των requests κρατάω στον πατέρα μια λίστα όπως αυτή που προαναφέρθηκε, αλλά 
ο κόμβος country αναφέρεται σε κάθε χώρα ξεχωριστά και αντί για bloom filters αποθηκεύουμε την ημερομηνία του κάθε request και 
το αν έγινε δεκτό ή όχι. 

Επιπλέον, έχω μια global struct όπου περιέχει διάφορες πληροφορίες χρήσιμες για τα παιδιά και κυρίως για τη 
διαχείριση των σημάτων και την εκτύπωση των στατιστικών των requests στα log files. Εννοείται,
υπάρχει και στον πατέρα η ίδια δομή, αλλά η μόνη πληροφορία που χρειάζεται είναι σχετικά με τα requests.

Οι συναρτήσεις, έχουν υλοποιηθεί σύμφωνα με την εκφώνηση. 
Για το travel request ψάχνουμε αν υπάρχει στο bloom filters. Aν δεν υπάρχει, βάζουμε το request στην προαναφερθείσα λίστα και
αποθηκεύουμε την πληροφορία στο global struct(ουστιαστικά είναι 3 counters:{ requests, accepted, rejected} ). 
Αν υπάρχει στο bloom filter, στέλνυομε μήνυμα στο αντίστοιχο παιδί και ψάχνει στο skip list.Ανάλογα με το αποτέλεσμα που βρήκε,
γυρνάει την αντίστοιχη πληροφορία στον πατέρα και αποθηκεύονται πάλι οι πληροφορίες για το request.

Το /travelStats απλά ψάχνει στην λίστα με τα requests του πατέρα και εκτυπώνει τα ανάλογα αποτελέσματα, σύμφωνα με το εκάστοτε input.

Το /addVaccinationRecords στέλνει USR1 μήνυμα στο παιδί. Αυτό το λαμβάνει και στέλνει πίσω στον πατέρα σήμα USR2 για να τον ξυπνήσει εάν
περιμένει για input στην fgets(). Ταυτόχρονα, στέλνει ένα πακέτο στον πατέρα με τις χώρες του. Ο πατέρας το λαμβάνει και το ξαναστέλνει πίσω
τις χώρες μία-μία όπως στο στάδιο της αρχικοποίησης. Ακολουθείται το ίδιο μοτίβο με την αρχικοποίηση και περιμένει ο πατέρας να λάβει τα
bloom filters.

To /searchVaccinationStatus απλά στέλνει το ίδιο μήνυμα σε όλα τα monitors και όποιο έχει κάποια πληροφορία την επιστρέφει.

Αν λάβουμε κάποιο signal τότε ο handler απλά αλλάζει την τιμή ενός flag και την χειριζόμαστε μετά με την sig_got().

Αν λάβουμε SIGINT / SIGQUIT στο παιδί εκτυπώνονται στα αντίστοιχο log file οι πληροφορίες που ζητώνται (και είναι αποθηκευμένες στο global struct).

Το SIGUSR1, το ανέφερα πριν.

Αν κάποιο παιδί τερματίσει ξαφνικά, δημιουργείται καινούργιο και ακολουθείται η διαδικασία σχεδόν ίδια με την αρχικοποίηση.

Το SIGINT/SIGQUIT στον πατέρα έχει το ίδιο αποτέλεσμα με την /exit, όπου στέλνονται SIGKILL στα monitors και αποδεσμεύεται η μνήμη στον πατέρα.

Κάτι ακόμα που ίσως χρειάζεται να αναφερθεί είναι το πως διαχειρίζεται τα signals ο πατέρας. Κατά το στάδιο της αρχικοποίησης,
καλώ μια συνάρτηση και περνάω σαν όρισμα την διεύθυνση μιας μεταβλητής 'sig_updates' που υπάρχει στην main(πατέρας). Εκέι αποθηκεύω την διεύθυνση
αυτή σε μια μεταβλητή μέσα στην συνάρτηση. Έτσι, την επόμενη φορά που θα την καλέσω για τη διαχείριση των σημάτων θα αλλάξω την τιμή αυτής της μεταβλητής
και η αλλαγή θα γίνει στην main, ώστε να διαχειριστώ αναλόγως το signal.

 








